input {
  # Beats input for Filebeat
  beats {
    port => 5044
    codec => json
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^{.*}$/ {
    json {
      source => "message"
      target => "parsed"
    }
  }

  # Extract container information
  if [container][name] {
    mutate {
      add_field => {
        "service_name" => "%{[container][name]}"
      }
    }
  } else {
    # Set default service name if not present
    mutate {
      add_field => {
        "service_name" => "unknown"
      }
    }
  }

  # Parse log level
  if [log][level] {
    mutate {
      add_field => { "log_level" => "%{[log][level]}" }
    }
  } else if [level] {
    mutate {
      add_field => { "log_level" => "%{[level]}" }
    }
  } else if [severity] {
    mutate {
      add_field => { "log_level" => "%{[severity]}" }
    }
  }

  # Normalize log levels
  if [log_level] {
    mutate {
      uppercase => [ "log_level" ]
    }
  }

  # Add timestamp
  date {
    match => [ "timestamp", "ISO8601", "UNIX", "UNIX_MS" ]
    target => "@timestamp"
  }

  # Grok patterns for common log formats
  grok {
    match => {
      "message" => [
        "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} \[%{DATA:service}\] %{GREEDYDATA:log_message}",
        "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:service}\] %{GREEDYDATA:log_message}",
        "\[%{TIMESTAMP_ISO8601:timestamp}\] %{LOGLEVEL:log_level}: %{GREEDYDATA:log_message}"
      ]
    }
    overwrite => [ "message" ]
  }

  # Parse microservice-specific data
  if [service_name] =~ /api-gateway/ {
    grok {
      match => {
        "message" => "%{IP:client_ip} - - \[%{HTTPDATE:timestamp}\] \"%{WORD:http_method} %{URIPATHPARAM:request_path} HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code} %{NUMBER:bytes}"
      }
    }
    mutate {
      add_field => { "service_type" => "gateway" }
    }
  }

  if [service_name] =~ /chat-service|game-service|notification-service/ {
    mutate {
      add_field => { "service_type" => "microservice" }
    }
  }

  # Add geographical information if IP is present
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Calculate response time if available
  if [response_time] {
    ruby {
      code => "event.set('response_time_ms', event.get('response_time').to_f * 1000)"
    }
  }

  # Error detection
  if [log_level] =~ /(?i)(ERROR|FATAL|CRITICAL)/ or [message] =~ /(?i)(error|exception|failed)/ {
    mutate {
      add_tag => [ "error" ]
      add_field => { "alert_level" => "high" }
    }
  }

  # Warning detection
  if [log_level] =~ /WARN|WARNING/ {
    mutate {
      add_tag => [ "warning" ]
      add_field => { "alert_level" => "medium" }
    }
  }

  # Security events detection
  if [message] =~ /(?i)(authentication|authorization|login|logout|access denied|forbidden)/ {
    mutate {
      add_tag => [ "security" ]
    }
  }

  # Performance monitoring
  if [response_time_ms] {
    if [response_time_ms] > 5000 {
      mutate {
        add_tag => [ "slow_response" ]
      }
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "agent", "ecs", "input" ]
  }
}

output {
  # Output to Elasticsearch with index patterns based on service
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
    
    # Dynamic index based on service name and date
    index => "logs-%{service_name}-%{+YYYY.MM.dd}"
    
    # Required for data streams
    action => "create"
    
    # Disable ILM to avoid policy errors
    ilm_enabled => false
  }

  # Error logs to separate index
  if "error" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTIC_PASSWORD}"
      index => "errors-%{service_name}-%{+YYYY.MM.dd}"
      action => "create"
      ilm_enabled => false
    }
  }

  # Security logs to separate index
  if "security" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTIC_PASSWORD}"
      index => "security-logs-%{+YYYY.MM.dd}"
      action => "create"
      ilm_enabled => false
    }
  }

  # Output to stdout for debugging (can be disabled in production)
  stdout {
    codec => rubydebug {
      metadata => true
    }
  }
}
